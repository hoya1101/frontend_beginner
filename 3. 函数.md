  
创建对象
---

## 构造函数

```javascript
function Person(name) {
  this.name = name;
}

var person = new Person();
```

经历4个步骤：
 1. 创建新对象
 2. 将构造函数的作用域赋值给新对象（this指向这个新对象）
 3. 执行代码
 4. 返回新对象
 
```javascript
person.constructor === Person

person instanceof Person; //true
```

## 原型
* 每个函数都有一个prototype属性，它是指针，指向对象。
* 共享属性和方法
```javascript
function foo() {};
console.log('foo.prototype:', foo.prototype)

function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function() {
  console.log('name:', this.name);
}

var person = new Person();
Person.prototype.constructor == Person

person.__proto__ === Person.prototype
```
#### Note:
  1. constructor属性是原型的属性
  2. 构造函数创建的实例，之所以能访问constructor是因为prototype的属性是共享的。
  
```javascript
person.constructor === Person.prototype.constructor
```

练习：
```javascript
function Person() {};

var person = new Person();

Person.prototype = {
  constructor : Person,
  sayHi : function() {}
}

person.sayHi();
```

## 继承和原型链

* 使用构造函数创建的实例，可以链接到构造函数的prototype
* 查找属性是一个查询的过程，本身实例，延展到prototype对象查找。

```javascript
function SuperType(name) {
  this.name = name
}

SuperType.prototype.say = function() {
  console.log(this.name);
}

function SubType() {
}

SubType.prototype = new SuperType();

var instance = new SubType();
instance.say();
```

问题：如何继承SuperType的name属性呢？

## 匿名函数

* 函数声明: 有名字，代码执行前被加载到作用域中
* 函数表达式: 没有名字，执行在所在code时，才会有定义。

```javascript
function foo() {};

var foo = function() {};
```

## 闭包

```javascript
function createFun(name) {
  return function(action) {
    console.log(action, name);
  }
}

var funSAP = createFun("sap");
funSAP("涨工资");
```

* 作用域和作用链
* 当函数第一次被调用，有一个scope内部属性，指向作用域链
* 活动对象，this，arguments，实例属性
* 另外一个函数内部定义的函数会将包含函数的活动对象添加到作用域链中
* 内部定义的匿名函数的作用域链中，实际上包含外部函数的活动对象

```javascript
function createFun() {
  var array = [];
  
  for (var i=0; i<10; i++) {
    array[i] = function() {
      return i;
    };
  }
  
  return array;
}

var funs = createFun();

for (var i=0; i<funs.length; i++) {
  console.log(funs[i]());
}
```

```javascript
function createFun() {
  var array = [];
  
  for (var i=0; i<10; i++) {
    array[i] = (function(num) {
      return function() {
        return num;
      };
    })(i)
  }
  
  return array;
}

var funs = createFun();

for (var i=0; i<funs.length; i++) {
  console.log(funs[i]());
}
```

## 递归
输出 `chirp-chirp-chirp`
```javascript
function chirp(n) {
  return n > 1 ? chirp(n-1) + "-chirp" : "chirp";
}
```

让人具备这样的能力：输出 `chirp-chirp-chirp`
```javascript
var ninja = {
  chirp : function(n) { // 将匿名函数赋值给对象的一个属性
    return n > 1 ? chirp(n-1) + "-chirp" : "chirp";
  }
}
```

```javascript
var ninja = {
  chirp : function(n) { // 将匿名函数赋值给对象的一个属性, 通过对象的属性调用函数自身
    return n > 1 ? ninja.chirp(n-1) + "-chirp" : "chirp";
  }
}
```

新创建一个对象，引用ninja对象上的匿名函数

```javascript
var ninja = {
  chirp : function(n) { // 将匿名函数赋值给对象的一个属性, 通过对象的属性调用函数自身
    return n > 1 ? ninja.chirp(n-1) + "-chirp" : "chirp";
  }
}

var samurai = {chirp : ninja.chirp};

ninja = null;

samurai.chirp(2);
```

函数上下文：函数被作为方法调用时，this指的是调用该方法的那个对象。
```javascript
var ninja = {
  chirp : function(n) { // 将匿名函数赋值给对象的一个属性, 通过对象的属性调用函数自身
    return n > 1 ? this.chirp(n-1) + "-chirp" : "chirp";
  }
}
```

## 内联命名函数
上个例子的问题，新创建的对象的函数名称必须为chirp。

```javascript
var ninja = {
  chirp : function signal(n) {  // 定义一个命名内联函数
    return n > 1 ? signal(n-1) + "-chirp" : "chirp";
  }
}

var samurai = {chirp1 : ninja.chirp};

ninja = null;

samurai.chirp1(2);
```

内联函数用于普通赋值，内联函数的名称在内联函数外部是不可用的。

```javascript
var ninja = function myNinja() {
  console.log(ninja == myNinja)
}

ninja();

console.log(myNinja);
```

Note: 为什么要把全局函数作为window的方法进行创建，否则没有办法引用这些函数。

## callee属性

```javascript
var ninja = {
  chirp : function(n) {  // arguments.callee引用当前调用函数
    return n > 1 ? arguments.callee(n-1) + "-chirp" : "chirp";
  }
}
```

## 将函数视为对象
JavaScript作为一等公民:
* 函数可以有属性
* 函数可以有方法 (function.call, function.apply)
* 函数可以有变量和属性
* 函数当然可以被调用的特性

还可以为函数增加属性：
```javascript
var fn = function() {};
fn.prop = "prop";
```

## 函数存储
存储一组相关但是又独立的函数，可以使用数组进行存储，然后遍历数组检查重复的函数。

```javascript
var store = {
  nextId : 1,
  cache  : {},
  add : function(fn) {
    if (!fn.id) {
      fn.id = store.nextId++;
      return !!(store.cache[fn.id] = fn)
    }
  }
}

function ninja() {}

store.add(ninja) == true;
store.add(ninja) == false;
```

## 自记忆函数
记住先前的计算结果，避免已经执行的不必要复杂计算，提高性能。

计算素数的算法
```javascript
function isPrime(value) {
  if (!isPrime.answers) isPrime.answer = {};
  if (isPrime.answers[value] != null) {
    return isPrime.answers[value];
  }
  var prime = value != 1;
  for (var i=2; i<value; i++) {
    if (value % i == 0) {
      prime = true;
      break;
    }
  }
  
  return isPrime.answers[value] = prime;
}

isPrime(5);
isPrime.answers[5]
```

## Javascript的this用法

http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html
